from __future__ import annotations
import os
import psycopg2
import psycopg2.extras
from dotenv import load_dotenv

# Auto-generated by codegen.py. Re-generate anytime.

def _safe_eval_predicate(expr: str, env: dict) -> bool:
    """
    English comments:
    Evaluate a predicate expression in a restricted environment.
    - Variables are taken from the given env dict.
    - Supports Python boolean logic (and/or/not).
    """
    if not expr:
        return True
    return bool(eval(expr, {"__builtins__": {}}, env))


def run_query():
    try:
        load_dotenv()
        user = os.getenv("USER")
        password = os.getenv("PASSWORD")
        dbname = os.getenv("DBNAME")
        host = os.getenv("HOST", "localhost")
        port = os.getenv("PORT", "5432")

        conn = psycopg2.connect(
            dbname=dbname,
            user=user,
            password=password,
            host=host,
            port=port,
            cursor_factory=psycopg2.extras.DictCursor
        )
        cur = conn.cursor()

    except:
        raise RuntimeError("Incorrect USER/PASSWORD/DBNAME in .env")

    # mf_struct maps grouping key tuple -> entry dict
    mf_struct = {}

    # SCAN 0: initialize mf_struct entries for distinct grouping keys
    cur.execute('SELECT * FROM sales')
    for row in cur:
        key = (row['state'], row['month'])
        if key not in mf_struct:
            entry = {}
            entry['state'] = row['state']
            entry['month'] = row['month']
            entry['1_sum_quant'] = 0
            entry['2_max_quant'] = None
            mf_struct[key] = entry

    # SCAN 1: compute aggregates for grouping variable 1
    cur.execute('SELECT * FROM sales')
    for row in cur:
        for _key, entry in mf_struct.items():
            env = dict(row)
            env['g_state'] = entry.get('state')
            env['g_month'] = entry.get('month')
            if not _safe_eval_predicate('state == g_state and month == g_month', env):
                continue
            entry['1_sum_quant'] += (row['quant'] if row['quant'] is not None else 0)

    # SCAN 2: compute aggregates for grouping variable 2
    cur.execute('SELECT * FROM sales')
    for row in cur:
        for _key, entry in mf_struct.items():
            env = dict(row)
            env['g_state'] = entry.get('state')
            env['g_month'] = entry.get('month')
            if not _safe_eval_predicate('state == g_state', env):
                continue
            val = row['quant']
            if val is not None:
                if entry['2_max_quant'] is None or val > entry['2_max_quant']:
                    entry['2_max_quant'] = val

    filtered_mf_struct = {}
    for _key, entry in mf_struct.items():
        if (entry['1_sum_quant'] >= entry['2_max_quant'] * 2 and entry['state'] == 'CA'):
             filtered_mf_struct[_key] = entry

    # Output
    out_cols = ['state', 'month', '1_sum_quant', '2_max_quant']
    print("\t".join(out_cols))
    for _key, entry in filtered_mf_struct.items():
        row_out = [str(entry.get(c, "")) for c in out_cols]
        print("\t".join(row_out))

    cur.close()
    conn.close()


if __name__ == "__main__":
    run_query()
