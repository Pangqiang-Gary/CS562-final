# Run this single cell in Google Colab to create the project folder.
import os

BASE = "/content/final_project"
os.makedirs(BASE, exist_ok=True)

files = {
    "phi_parser.py": 'from __future__ import annotations\n\nfrom dataclasses import dataclass\nfrom typing import Dict, List, Optional\nimport re\n\n\n@dataclass\nclass AggSpec:\n    gv: str          # grouping variable id, e.g., "1"\n    func: str        # sum/count/avg/min/max\n    col: str         # column name or "*"\n    alias: str       # internal/output field name\n\n\n@dataclass\nclass PhiSpec:\n    select_attrs: List[str]           # S:\n    num_gv: int                       # n:\n    grouping_attrs: List[str]         # V:\n    aggs: List[AggSpec]               # F:\n    predicates: Dict[str, str]        # sigma: gv -> predicate string (Python expression over env dict)\n\n\n_FUNC_CANON = {"sum": "sum", "count": "count", "avg": "avg", "min": "min", "max": "max"}\n\n# Accept tokens like: 1_sum_quant, 2_avg_price, 3_count_*\n_AGG_RE = re.compile(r"^\\s*(\\d+)\\s*_(sum|count|avg|min|max)\\s*_\\s*([A-Za-z_][A-Za-z0-9_]*|\\*)\\s*$", re.I)\n\n\ndef parse_phi_file(path: str) -> PhiSpec:\n    """\n    English comments:\n    Tolerant parser for a common MF-structure "phi" input format.\n\n    Expected sections:\n      S: <select list>\n      n: <num grouping variables>\n      V: <grouping attributes>\n      F: <aggregate list>\n      sigma:\n        <gv>: <predicate expression>\n        ...\n\n    Notes:\n    - Separators can be commas or whitespace.\n    - Predicates use Python boolean logic: and/or/not\n    - Use single quotes for strings.\n    - Predicates are evaluated over an environment dict containing:\n        * row columns from sales\n        * grouping attributes for the current MF entry\n    """\n    with open(path, "r", encoding="utf-8") as f:\n        raw = f.read()\n\n    # Strip \'#\' comments and empty lines\n    lines: List[str] = []\n    for ln in raw.splitlines():\n        ln = re.sub(r"#.*$", "", ln).strip()\n        if ln:\n            lines.append(ln)\n\n    S: Optional[str] = None\n    n: Optional[str] = None\n    V: Optional[str] = None\n    F: Optional[str] = None\n    sigma_lines: List[str] = []\n\n    mode: Optional[str] = None\n    for ln in lines:\n        lower = ln.lower()\n        if lower.startswith("s:"):\n            mode = "S"\n            S = ln.split(":", 1)[1].strip()\n            continue\n        if lower.startswith("n:"):\n            mode = "n"\n            n = ln.split(":", 1)[1].strip()\n            continue\n        if lower.startswith("v:"):\n            mode = "V"\n            V = ln.split(":", 1)[1].strip()\n            continue\n        if lower.startswith("f:"):\n            mode = "F"\n            F = ln.split(":", 1)[1].strip()\n            continue\n        if lower.startswith("sigma:"):\n            mode = "sigma"\n            rest = ln.split(":", 1)[1].strip()\n            if rest:\n                sigma_lines.append(rest)\n            continue\n\n        # Continuation lines\n        if mode == "sigma":\n            sigma_lines.append(ln)\n        elif mode == "S" and S is not None:\n            S += " " + ln\n        elif mode == "V" and V is not None:\n            V += " " + ln\n        elif mode == "F" and F is not None:\n            F += " " + ln\n        elif mode == "n" and n is not None:\n            n += " " + ln\n\n    if S is None or n is None or V is None:\n        raise ValueError("phi input must include S:, n:, V: sections.")\n\n    select_attrs = _split_list(S)\n    num_gv = int(_first_token(n))\n    grouping_attrs = _split_list(V)\n\n    aggs: List[AggSpec] = []\n    if F:\n        for item in _split_list(F):\n            m = _AGG_RE.match(item)\n            if not m:\n                raise ValueError(f"Invalid aggregate token in F: \'{item}\'. Expected like \'1_sum_quant\'.")\n            gv = m.group(1)\n            func = _FUNC_CANON[m.group(2).lower()]\n            col = m.group(3)\n            alias = f"{gv}_{func}_{col}"\n            aggs.append(AggSpec(gv=gv, func=func, col=col, alias=alias))\n\n    predicates: Dict[str, str] = {}\n    for ln in sigma_lines:\n        # Accept: "1: ..." or "1 -> ..." or "1 - ..."\n        m = re.match(r"^\\s*(\\d+)\\s*[:\\- >]+\\s*(.+)\\s*$", ln)\n        if m:\n            gv = m.group(1)\n            pred = m.group(2).strip()\n            predicates[gv] = pred\n        else:\n            # If no gv is provided, append to gv=1 by AND\n            if "1" not in predicates:\n                predicates["1"] = ln.strip()\n            else:\n                predicates["1"] = f"({predicates[\'1\']}) and ({ln.strip()})"\n\n    return PhiSpec(\n        select_attrs=select_attrs,\n        num_gv=num_gv,\n        grouping_attrs=grouping_attrs,\n        aggs=aggs,\n        predicates=predicates,\n    )\n\n\ndef _split_list(s: str) -> List[str]:\n    parts: List[str] = []\n    for chunk in s.split(","):\n        chunk = chunk.strip()\n        if not chunk:\n            continue\n        parts.extend(chunk.split())\n    return [p.strip() for p in parts if p.strip()]\n\n\ndef _first_token(s: str) -> str:\n    return s.strip().split()[0]\n',
    "codegen.py": 'from __future__ import annotations\n\nimport sys\nimport textwrap\nfrom typing import Dict, List\n\nfrom phi_parser import parse_phi_file, PhiSpec, AggSpec\n\n\ndef _emit_header() -> str:\n    return textwrap.dedent(\n        """        from __future__ import annotations\n        import os\n        import psycopg2\n        import psycopg2.extras\n        from dotenv import load_dotenv\n\n        # Auto-generated by codegen.py. Re-generate anytime.\n\n        def _safe_eval_predicate(expr: str, env: dict) -> bool:\n            \\"\\"\\"\n            English comments:\n            Evaluate a predicate expression in a restricted environment.\n            - Variables are taken from the given env dict.\n            - Supports Python boolean logic (and/or/not).\n            \\"\\"\\"\n            if not expr:\n                return True\n            return bool(eval(expr, {"__builtins__": {}}, env))\n\n\n        def run_query():\n            load_dotenv()\n            user = os.getenv("USER")\n            password = os.getenv("PASSWORD")\n            dbname = os.getenv("DBNAME")\n            host = os.getenv("HOST", "localhost")\n            port = os.getenv("PORT", "5432")\n\n            if not user or not password or not dbname:\n                raise RuntimeError("Missing USER/PASSWORD/DBNAME in .env")\n\n            conn = psycopg2.connect(\n                dbname=dbname,\n                user=user,\n                password=password,\n                host=host,\n                port=port,\n                cursor_factory=psycopg2.extras.DictCursor\n            )\n            cur = conn.cursor()\n\n            # mf_struct maps grouping key tuple -> entry dict\n            mf_struct = {}\n        """\n    )\n\n\ndef _agg_field_name(a: AggSpec) -> str:\n    return a.alias\n\n\ndef _emit_init_for_agg(a: AggSpec) -> str:\n    name = _agg_field_name(a)\n    if a.func in ("sum", "count"):\n        return f"entry[\'{name}\'] = 0"\n    if a.func in ("min", "max"):\n        return f"entry[\'{name}\'] = None"\n    if a.func == "avg":\n        return (\n            f"entry[\'{name}__sum\'] = 0\\n"\n            f"entry[\'{name}__count\'] = 0\\n"\n            f"entry[\'{name}\'] = 0"\n        )\n    raise ValueError(f"Unsupported agg func: {a.func}")\n\n\ndef _emit_update_for_agg(a: AggSpec) -> str:\n    name = _agg_field_name(a)\n\n    if a.func == "count":\n        return f"entry[\'{name}\'] += 1"\n\n    if a.func == "sum":\n        col = a.col\n        return f"entry[\'{name}\'] += (row[\'{col}\'] if row[\'{col}\'] is not None else 0)"\n\n    if a.func == "min":\n        col = a.col\n        return textwrap.dedent(\n            f"""            val = row[\'{col}\']\n            if val is not None:\n                if entry[\'{name}\'] is None or val < entry[\'{name}\']:\n                    entry[\'{name}\'] = val\n            """\n        ).rstrip()\n\n    if a.func == "max":\n        col = a.col\n        return textwrap.dedent(\n            f"""            val = row[\'{col}\']\n            if val is not None:\n                if entry[\'{name}\'] is None or val > entry[\'{name}\']:\n                    entry[\'{name}\'] = val\n            """\n        ).rstrip()\n\n    if a.func == "avg":\n        col = a.col\n        return textwrap.dedent(\n            f"""            val = row[\'{col}\']\n            if val is not None:\n                entry[\'{name}__sum\'] += val\n                entry[\'{name}__count\'] += 1\n                entry[\'{name}\'] = entry[\'{name}__sum\'] / entry[\'{name}__count\']\n            """\n        ).rstrip()\n\n    raise ValueError(f"Unsupported agg func: {a.func}")\n\n\ndef _emit_footer(spec: PhiSpec) -> str:\n    out_cols = spec.select_attrs\n    cols_py = "[" + ", ".join([repr(c) for c in out_cols]) + "]"\n    return textwrap.dedent(\n        f"""            # Output\n            out_cols = {cols_py}\n            print("\\\\t".join(out_cols))\n            for _key, entry in mf_struct.items():\n                row_out = [str(entry.get(c, "")) for c in out_cols]\n                print("\\\\t".join(row_out))\n\n            cur.close()\n            conn.close()\n\n\n        if __name__ == "__main__":\n            run_query()\n        """\n    )\n\n\ndef _emit_scan0(spec: PhiSpec) -> str:\n    V = spec.grouping_attrs\n    lines: List[str] = []\n    lines.append("    # SCAN 0: initialize mf_struct entries for distinct grouping keys")\n    lines.append("    cur.execute(\'SELECT * FROM sales\')")\n    lines.append("    for row in cur:")\n    key_expr = "(" + ", ".join([f"row[\'{v}\']" for v in V]) + ("," if len(V) == 1 else "") + ")"\n    lines.append(f"        key = {key_expr}")\n    lines.append("        if key not in mf_struct:")\n    lines.append("            entry = {}")\n    for v in V:\n        lines.append(f"            entry[\'{v}\'] = row[\'{v}\']")\n    for a in spec.aggs:\n        for ln in _emit_init_for_agg(a).splitlines():\n            lines.append("            " + ln)\n    lines.append("            mf_struct[key] = entry")\n    return "\\n".join(lines) + "\\n"\n\n\ndef _emit_scans(spec: PhiSpec) -> str:\n    V = spec.grouping_attrs\n    n = spec.num_gv\n\n    gv_aggs: Dict[str, List[AggSpec]] = {}\n    for a in spec.aggs:\n        gv_aggs.setdefault(a.gv, []).append(a)\n\n    blocks: List[str] = []\n    for i in range(1, n + 1):\n        gv = str(i)\n        pred = spec.predicates.get(gv, "")\n\n        blocks.append(f"    # SCAN {i}: compute aggregates for grouping variable {i}")\n        blocks.append("    cur.execute(\'SELECT * FROM sales\')")\n        blocks.append("    for row in cur:")\n        blocks.append("        for _key, entry in mf_struct.items():")\n        blocks.append("            env = dict(row)")\n        for v in V:\n            blocks.append(f"            env[\'{v}\'] = entry.get(\'{v}\')")\n        if pred:\n            blocks.append(f"            if not _safe_eval_predicate({pred!r}, env):")\n            blocks.append("                continue")\n        for a in gv_aggs.get(gv, []):\n            for ln in _emit_update_for_agg(a).splitlines():\n                blocks.append("            " + ln)\n        blocks.append("")\n\n    return "\\n".join(blocks)\n\n\ndef generate_qpe(spec: PhiSpec) -> str:\n    return "\\n".join([_emit_header(), _emit_scan0(spec), _emit_scans(spec), _emit_footer(spec)])\n\n\ndef main() -> None:\n    if len(sys.argv) != 3:\n        print("Usage: python codegen.py <phi_input.txt> <out_qpe.py>")\n        sys.exit(2)\n\n    phi_path = sys.argv[1]\n    out_path = sys.argv[2]\n\n    spec = parse_phi_file(phi_path)\n    code = generate_qpe(spec)\n\n    with open(out_path, "w", encoding="utf-8") as f:\n        f.write(code)\n\n    print(f"Generated: {out_path}")\n\n\nif __name__ == "__main__":\n    main()\n',
    "phi_input.txt": '# Example phi input (edit to match your assignment)\nS: cust, 1_sum_quant, 1_avg_quant\nn: 1\nV: cust\nF: 1_sum_quant, 1_avg_quant\nsigma:\n  1: quant is not None\n',
    "requirements.txt": 'psycopg2-binary\npython-dotenv\n',
    ".env.example": 'USER=postgres\nPASSWORD=your_password\nDBNAME=your_db\nHOST=localhost\nPORT=5432\n',
    "README.md": "# Colab-ready MF-Structure Final Project\n\n## Files\n- `phi_input.txt`: query specification (S, n, V, F, sigma)\n- `codegen.py`: generates `qpe.py` from `phi_input.txt`\n- `qpe.py`: generated executable (connects to PostgreSQL, scans `sales`)\n\n## Colab usage\n```bash\npip -q install -r requirements.txt\n# create .env (edit values)\ncat > .env << 'EOF'\nUSER=postgres\nPASSWORD=your_password\nDBNAME=your_db\nHOST=localhost\nPORT=5432\nEOF\n\npython codegen.py phi_input.txt qpe.py\npython qpe.py\n```\n",
}

for name, content in files.items():
    with open(os.path.join(BASE, name), "w", encoding="utf-8") as f:
        f.write(content)

print("Created:", BASE)
print("Files:", sorted(os.listdir(BASE)))
