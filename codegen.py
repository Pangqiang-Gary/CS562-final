from __future__ import annotations

import sys
import textwrap
from typing import Dict, List

from phi_parser import parse_phi_file, PhiSpec, AggSpec


def _emit_header() -> str:
    return textwrap.dedent(
        """        from __future__ import annotations
        import os
        import psycopg2
        import psycopg2.extras
        from dotenv import load_dotenv

        # Auto-generated by codegen.py. Re-generate anytime.

        def _safe_eval_predicate(expr: str, env: dict) -> bool:
            \"\"\"
            English comments:
            Evaluate a predicate expression in a restricted environment.
            - Variables are taken from the given env dict.
            - Supports Python boolean logic (and/or/not).
            \"\"\"
            if not expr:
                return True
            return bool(eval(expr, {"__builtins__": {}}, env))


        def run_query():
            try:
                load_dotenv()
                user = os.getenv("USER")
                password = os.getenv("PASSWORD")
                dbname = os.getenv("DBNAME")
                host = os.getenv("HOST", "localhost")
                port = os.getenv("PORT", "5432")

            except:
                raise RuntimeError("Incorrect USER/PASSWORD/DBNAME in .env")

            conn = psycopg2.connect(
                dbname=dbname,
                user=user,
                password=password,
                host=host,
                port=port,
                cursor_factory=psycopg2.extras.DictCursor
            )
            cur = conn.cursor()

            # mf_struct maps grouping key tuple -> entry dict
            mf_struct = {}
        """
    )


def _agg_field_name(a: AggSpec) -> str:
    return a.alias


def _emit_init_for_agg(a: AggSpec) -> str:
    name = _agg_field_name(a)
    if a.func in ("sum", "count"):
        return f"entry['{name}'] = 0"
    if a.func in ("min", "max"):
        return f"entry['{name}'] = None"
    if a.func == "avg":
        return (
            f"entry['{name}__sum'] = 0\n"
            f"entry['{name}__count'] = 0\n"
            f"entry['{name}'] = 0"
        )
    raise ValueError(f"Unsupported agg func: {a.func}")


def _emit_update_for_agg(a: AggSpec) -> str:
    name = _agg_field_name(a)

    if a.func == "count":
        return f"entry['{name}'] += 1"

    if a.func == "sum":
        col = a.col
        return f"entry['{name}'] += (row['{col}'] if row['{col}'] is not None else 0)"

    if a.func == "min":
        col = a.col
        return textwrap.dedent(
            f"""            val = row['{col}']
            if val is not None:
                if entry['{name}'] is None or val < entry['{name}']:
                    entry['{name}'] = val
            """
        ).rstrip()

    if a.func == "max":
        col = a.col
        return textwrap.dedent(
            f"""            val = row['{col}']
            if val is not None:
                if entry['{name}'] is None or val > entry['{name}']:
                    entry['{name}'] = val
            """
        ).rstrip()

    if a.func == "avg":
        col = a.col
        return textwrap.dedent(
            f"""            val = row['{col}']
            if val is not None:
                entry['{name}__sum'] += val
                entry['{name}__count'] += 1
                entry['{name}'] = entry['{name}__sum'] / entry['{name}__count']
            """
        ).rstrip()

    raise ValueError(f"Unsupported agg func: {a.func}")


def _emit_footer(spec: PhiSpec) -> str:
    out_cols = spec.select_attrs
    cols_py = "[" + ", ".join([repr(c) for c in out_cols]) + "]"
    return textwrap.dedent(
        f"""            # Output
            out_cols = {cols_py}
            print("\\t".join(out_cols))
            for _key, entry in mf_struct.items():
                row_out = [str(entry.get(c, "")) for c in out_cols]
                print("\\t".join(row_out))

            cur.close()
            conn.close()


        if __name__ == "__main__":
            run_query()
        """
    )


def _emit_scan0(spec: PhiSpec) -> str:
    V = spec.grouping_attrs
    lines: List[str] = []
    lines.append("    # SCAN 0: initialize mf_struct entries for distinct grouping keys")
    lines.append("    cur.execute('SELECT * FROM sales')")
    lines.append("    for row in cur:")
    key_expr = "(" + ", ".join([f"row['{v}']" for v in V]) + ("," if len(V) == 1 else "") + ")"
    lines.append(f"        key = {key_expr}")
    lines.append("        if key not in mf_struct:")
    lines.append("            entry = {}")
    for v in V:
        lines.append(f"            entry['{v}'] = row['{v}']")
    for a in spec.aggs:
        for ln in _emit_init_for_agg(a).splitlines():
            lines.append("            " + ln)
    lines.append("            mf_struct[key] = entry")
    return "\n".join(lines) + "\n"


def _emit_scans(spec: PhiSpec) -> str:
    V = spec.grouping_attrs
    n = spec.num_gv

    gv_aggs: Dict[str, List[AggSpec]] = {}
    for a in spec.aggs:
        gv_aggs.setdefault(a.gv, []).append(a)

    blocks: List[str] = []
    for i in range(1, n + 1):
        gv = str(i)
        pred = spec.predicates.get(gv, "")

        blocks.append(f"    # SCAN {i}: compute aggregates for grouping variable {i}")
        blocks.append("    cur.execute('SELECT * FROM sales')")
        blocks.append("    for row in cur:")
        blocks.append("        for _key, entry in mf_struct.items():")
        blocks.append("            env = dict(row)")
        for v in V:
            blocks.append(f"            env['g_{v}'] = entry.get('{v}')")
        if pred:
            blocks.append(f"            if not _safe_eval_predicate({pred!r}, env):")
            blocks.append("                continue")
        for a in gv_aggs.get(gv, []):
            for ln in _emit_update_for_agg(a).splitlines():
                blocks.append("            " + ln)
        blocks.append("")

    return "\n".join(blocks)


def generate_qpe(spec: PhiSpec) -> str:
    return "\n".join([_emit_header(), _emit_scan0(spec), _emit_scans(spec), _emit_footer(spec)])


def main() -> None:
    if len(sys.argv) != 3:
        print("Usage: python codegen.py <phi_input.txt> <out_qpe.py>")
        sys.exit(2)

    phi_path = sys.argv[1]
    out_path = sys.argv[2]

    spec = parse_phi_file(phi_path)
    code = generate_qpe(spec)

    with open(out_path, "w", encoding="utf-8") as f:
        f.write(code)

    print(f"Generated: {out_path}")


if __name__ == "__main__":
    main()
