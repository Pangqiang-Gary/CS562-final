from __future__ import annotations
import os
import psycopg2
import psycopg2.extras
from dotenv import load_dotenv

# Auto-generated by codegen.py. Re-generate anytime.

def _safe_eval_predicate(expr: str, env: dict) -> bool:
    """
    English comments:
    Evaluate a predicate expression in a restricted environment.
    - Variables are taken from the given env dict.
    - Supports Python boolean logic (and/or/not).
    """
    if not expr:
        return True
    return bool(eval(expr, {"__builtins__": {}}, env))


def run_query():
    load_dotenv()
    user = os.getenv("USER")
    password = os.getenv("PASSWORD")
    dbname = os.getenv("DBNAME")
    host = os.getenv("HOST", "localhost")
    port = os.getenv("PORT", "5432")

    if not user or not password or not dbname:
        raise RuntimeError("Missing USER/PASSWORD/DBNAME in .env")

    conn = psycopg2.connect(
        dbname=dbname,
        user=user,
        password=password,
        host=host,
        port=port,
        cursor_factory=psycopg2.extras.DictCursor
    )
    cur = conn.cursor()

    # mf_struct maps grouping key tuple -> entry dict
    mf_struct = {}

    # SCAN 0: initialize mf_struct entries for distinct grouping keys
    cur.execute('SELECT * FROM sales')
    for row in cur:
        key = (row['cust'],)
        if key not in mf_struct:
            entry = {}
            entry['cust'] = row['cust']
            entry['1_count_*'] = 0
            entry['1_max_quant'] = None
            mf_struct[key] = entry

    # SCAN 1: compute aggregates for grouping variable 1
    cur.execute('SELECT * FROM sales')
    for row in cur:
        for _key, entry in mf_struct.items():
            env = dict(row)
            env['g_cust'] = entry.get('cust')
            if not _safe_eval_predicate('(cust == g_cust) and (quant is not None)', env):
                continue
            entry['1_count_*'] += 1
            val = row['quant']
            if val is not None:
                if entry['1_max_quant'] is None or val > entry['1_max_quant']:
                    entry['1_max_quant'] = val

    # Output
    out_cols = ['cust', '1_count_*', '1_max_quant']
    print("\t".join(out_cols))
    for _key, entry in mf_struct.items():
        row_out = [str(entry.get(c, "")) for c in out_cols]
        print("\t".join(row_out))

    cur.close()
    conn.close()


if __name__ == "__main__":
    run_query()
